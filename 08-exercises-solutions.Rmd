# Exercise solutions

## Toolbox

### Get set up

No solution for this one.

### Résumé

No solution for this one.


## Basic R

### Math in the console

```{r results = 'hold'}
31 + 11
66 - 24
126 / 3
12^2 
256**0.5
(3 * (4 + 8^0.5))/(5^3)
```


### First look at functions

**A**  

View the help page for `paste()`. There are two variants of this function. Which? And what is the difference between them? Use both variants to generate _exactly_ this message `"welcome to R"` from these arguments: `"welcome ", "to ", "R"`

Answer: `paste()` and `paste0()`. The difference lies in the _separator_, which is an empty string in `paste0()` and one space in `paste()`. Moreover, the separator can be configured in `paste()` using the `sep = ` parameter.

```{r paste-ex-1}
paste("welcome ", "to ", "R", sep = "")
paste0("welcome ", "to ", "R")
```

**B**  

What does the `abs` function do? What is returned by `abs(-20)` and what is `abs(20)`?  

Answer: `abs()` returns the _absolute_ value. Simply put, a number with the minus sign removed if present.

```{r abs-ex-1}
abs(-20)
abs(20)
```

**C**  

What does the `c` function do? What is the difference in returned value (result) of `c()` when you combine either `1`, `3` and `"a"` as arguments, or `1`, `2` and `3`? Use the function `class()` to answer this.   

Answer: it combines (**c**oncatenates) its arguments into a single vector. The first example creates a "character" (text data) and the second a "numeric" (numeric data).

```{r c-ex-1}
c(1, 2, "a")
class(c(1, 2, "a"))
c(1, 2, 3)
class(c(1, 2, 3))
```


### Variables

```{r variables-ex-1}
x <- 20
y <- 10
z <- 3

x + y
x^z
#OR
#x**z
q <- x * y * z
sqrt(q)
q/pi
log10(x * y)
```


### Plotting rules {-}

Since everything needs to be done in a (corona virus induced) rush, plots may be (far) from perfect. Sorry about that.

### Stair walking and heart rate 

```{r stair-walking-exp-1, out.width='80%', fig.asp=.75, fig.align='center'}
#number of steps on the stairs
stair_height <- c(0, 5, 10, 15, 20, 25, 30, 35)
#heart rate after ascending the stairs
heart_rate <- c(66, 65, 67, 69, 73, 79, 86, 97)
plot(heart_rate ~ stair_height,
      main = "Heart rate versus stair height",
      xlab = "number of steps",
      ylab = "heart rate (beats/minute)",
      type = "l",
      lwd = 2,
      col = "blue")
```

### More subjects

```{r stair-walking-exp-2, out.width='80%', fig.asp=.75, fig.align='center'}
#number of steps on the stairs
stair_height <- c(0, 5, 10, 15, 20, 25, 30, 35)
#heart rates for subjects with normal weight
heart_rate_1 <- c(66, 65, 67, 69, 73, 79, 86, 97)
heart_rate_2 <- c(61, 61, 63, 68, 74, 81, 89, 104)
#heart rates for obese subjects
heart_rate_3 <- c(58, 60, 67, 71, 78, 89, 104, 121)
heart_rate_4 <- c(69, 73, 77, 83, 88, 96, 102, 127)
plot(x = stair_height,
    y = heart_rate_1,
    main = "Heart rate vs stair height",
    xlab = "number of steps",
    ylab = "heart rate (beats/min.)",
    type = "b",
    lwd = 2,
    col = "green",
    ylim = c(55, 130))
points(x = stair_height,
    y = heart_rate_2,
    col = "green",
    type = "b",
    lwd = 2)
points(x = stair_height,
    y = heart_rate_3,
    col = "red",
    type = "b",
    lwd = 2)
points(x = stair_height,
    y = heart_rate_4,
    col = "red",
    type = "b",
    lwd = 2)
```

### Chickens on a diet

```{r chicken-diets1, out.width='80%', fig.asp=.75, fig.align='center'}

time <- c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 21)
chick_1 <- c(42, 51, 59, 64, 76, 93, 106, 125, 149, 171, 199, 205)
chick_2 <- c(40, 49, 58, 72, 84, 103, 122, 138, 162, 187, 209, 215)
chick_3 <- c(42, 53, 62, 73, 85, 102, 123, 138, 170, 204, 235, 256)
chick_4 <- c(41, 49, 61, 74, 98, 109, 128, 154, 192, 232, 280, 290)

plot(x = time, y = chick_1,
         type = "l",
         lwd = 2,
         col = "blue",
         ylim = c(40, 300))
points(x = time, y = chick_2,
         type = "l",
         lwd = 2,
         lty = 3,
         col = "blue")
points(x = time, y = chick_3,
         type = "l",
         lwd = 2,
         lty = 1,
         col = "red")
points(x = time, y = chick_4,
         type = "l",
         lwd = 2,
         lty = 3,
         col = "red")
```

### Chicken bar plot

```{r chicken-diets2, out.width='80%', fig.asp=.75, fig.align='center'}
maxima <- c(max(chick_1), max(chick_2), max(chick_3), max(chick_4))

barplot(maxima,
    names = c("Chick 1","Chick 2","Chick 3","Chick 4"),
    ylab = "Maximum weight (grams)",
    col = "gold",
    main = "Maximum chick weights")
```

### Discoveries 

**A**    

```{r discoveries-1, out.width='80%', fig.asp=.75, fig.align='center'}
barplot(table(discoveries),
    main = "great discoveries per year",
    xlab = "number of discoveries",
    ylab = "frequency",
    col = "green")
```

**B**    

```{r discoveries-2, eval = FALSE}
summary(discoveries)
```

**C**    

```{r discoveries-3, out.width='80%', fig.asp=.75, fig.align='center'}
plot(discoveries,
         xlab = "year",
         ylab = "number of discoveries",
         main = "Great discoveries",
         col = "blue", 
         lwd = 2)
```


### Lung cancer    

**A**    

```{r lung-cancer-1, out.width='80%', fig.asp=.75, fig.align='center'}
total.col <- "red"
m.col <- "blue"
f.col <- "green"
plot(ldeaths,
         main = "deaths from lung cancer",
         xlab = "year",
         ylab = "number",
         col = total.col,
         ylim = c(0, 4000),
         lwd = 2
)
lines(fdeaths, col = f.col, lwd = 2)
lines(mdeaths, col = m.col, lwd = 2)
legend(
    "topleft", 
    legend = c("total", "female", "male"), 
    col = c(total.col, f.col, m.col), 
    lty = 1)
```

**B**   

Create a combined boxplot of the three time-series. Are they indicative of a normal distribution? Are there outliers? If so, can you figure out when this occurred?

```{r lung-cancer-2, out.width='80%', fig.asp=.75, fig.align='center'}
boxplot(
    fdeaths, mdeaths, ldeaths
)
```


## Complex datatypes

### Creating factors

**A**  

```{r eval = FALSE}
animal_risk <- c(2, 4, 1, 1, 2, 4, 1, 4, 1, 1, 2, 1)
animal_risk_factor <- factor(x = animal_risk,
                             levels = c(1, 2, 3, 4),
                             labels = c("harmless", "risky", "dangerous", "deadly"),
                             ordered = TRUE)
barplot(table(animal_risk_factor))
```

**B**  

```{r}
set.seed(1234)
wealth_male <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.7, 0.17, 0.12, 0.01))
wealth_female <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.8, 0.15, 0.497, 0.003))

wealth_labels <- c("poor", "middle class", "wealthy", "rich")

wealth_male_f <- factor(x = wealth_male,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

wealth_female_f <- factor(x = wealth_female,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

#combine
wealth_all_f <- factor(c(wealth_male_f, wealth_female_f),
                        levels = 1:4,
                        labels = wealth_labels,
                        ordered = TRUE)

prop.table(table(wealth_all_f)) * 100

#getting this data right may be a bit of a challenge...
bar_data <- rbind(table(wealth_female_f), table(wealth_male_f))
rownames(bar_data) <- c("female", "male")

barplot(bar_data, beside = T, legend = rownames(bar_data))
```


### A dictionary with a named vector

**A**    

```{r named-vector-1}
codons <- c("G", "P", "K", "S")
names(codons) <- c("GGA", "CCU", "AAA", "AGU")

my_DNA <- "GGACCUAAAAGU"
my_prot <- ""
for (i in seq(from = 1, to = nchar(my_DNA), by = 3)) {
        codon <- substr(my_DNA, i, i+2)
        my_prot <- paste0(my_prot, codons[codon])
}
print(my_prot)
```

**B**    

```{r eval = F}
nuc_weights <- c(491.2, 467.2, 507.2, 482.2)
names(nuc_weights) <- c('A', 'C', 'G', 'U')

mol_weight <- 0
for (i in 1:nchar(my_DNA)) {
        nuc <- substr(my_DNA, i, i);
        print(nuc)
        mol_weight <- mol_weight + nuc_weights[nuc]
}
mol_weight
```


### airquality 

**A**    

```{r airquality-1, out.width='80%', fig.asp=.75, fig.align='center'}
plot(airquality$Solar.R, airquality$Temp,
         main = "Temperature as a function of Solar radiation",
         xlab = "Solar radiation (lang)",
         ylab = "Temperature (F)")
abline(lm(airquality$Temp ~ airquality$Solar.R), col = "blue", lwd = 2)
```

**B**    

```{r airquality-2, out.width='80%', fig.asp=.75, fig.align='center'}
with(airquality, 
        boxplot(Temp ~ Month, 
        main = "Temperature over the months",
        xlab = "Month",
        ylab = "Temperature (F)"))
```

**C**    

```{r airquality-3, out.width='80%', fig.asp=.75, fig.align='center'}
#first create Temp Celcius column:
#(°F    -    32)    x    5/9 = °C
airquality$Temp.C <- (airquality$Temp - 32) * 5/9
#get the required data
airquality[airquality$Temp.C == min(airquality$Temp.C), c("Temp.C", "Month", "Day")]
```

**D**    

```{r airquality-4, out.width='80%', fig.asp=.75, fig.align='center'}
hist(airquality$Wind, xlab = "Wind speed (mph)")
abline(v = mean(airquality$Wind), col = "blue", lwd = 2)
abline(v = median(airquality$Wind), col = "red", lwd = 2)
```

**E**    

```{r airquality-5, out.width='80%', fig.asp=.75, fig.align='center'}
pairs(airquality, panel = panel.smooth)
```

Calculate pairwise correlation.
```{r airquality-cor, eval = FALSE}
cor(na.omit(airquality))
```


### Bird observations

```{r load-bird-observations}
bird_obs <- read.table("data/Observations-Data-2014.csv", 
                                             sep=";", 
                                             head=T, 
                                             na.strings = "", 
                                             quote = "", 
                                             comment.char = "")
```


**A**    

```{r, eval = FALSE}
## look at the loaded data structure
str(bird_obs)
```

Apparently, all variables are loaded as a factor; also the `Date.start`, `Date.end` (should be dates of course), `Number` (should be `integer`) and `Notes` (should be `character`) columns. In the original column names there are spaces and these are replaced by dots. First column `Species..` is a serial number and the second `Species` is the English species name.

**B**    

```{r, eval = FALSE}
nrow(bird_obs)
```

**C**    

```{r, eval = FALSE}
class(bird_obs$Number)
```

**D**    

```{r}
bird_obs$Count <- as.integer(bird_obs$Number)
head(bird_obs[, c(4, 8, 14)], n=50)
```

The factor **_levels_** have been converted into integers, not the original values!

**E**    

```{r}
#read with as.is argument
bird_obs <- read.table("data/Observations-Data-2014.csv",
                                sep=";",
                                head=T,
                                na.strings = "",
                                quote = "",
                                comment.char = "",
                                as.is = c(1, 6, 7, 8, 13))
str(bird_obs)
```

Convert Number column to Count of integers.

```{r}
bird_obs$Count <- as.integer(bird_obs$Number)
```

Note that there are other ways to achieve this, e.g. the `colClasses` argument to `read.table()`.

**F**    

```{r, eval = FALSE}
head(bird_obs[, c(4, 8, 14)], n=50)
sum(is.na(bird_obs$Count))
```

**G**    

```{r, eval = FALSE}
#What is the maximum number of birds in a single sighting?
bird_obs[which(bird_obs$Count == max(bird_obs$Count, na.rm = T)), ]
##OR
bird_obs[!is.na(bird_obs$Count) & bird_obs$Count == max(bird_obs$Count, na.rm = T), ]

#What is the mean sighting count
mean(bird_obs$Count, na.rm = T)

#What is the median of the sighting count
median(bird_obs$Count, na.rm = T)
```

**H**    

```{r bird-obs-1, out.width='80%', fig.asp=.75, fig.align='center'}
hist(bird_obs$Count)
```

Not very helpful, now is it? Try fiddling with the `breaks` argument.

```{r bird-obs-2, out.width='80%', fig.asp=.75, fig.align='center'}
plot(density(bird_obs$Count, na.rm=T),
         main = "density of Counts")
```

Better results with a log transformation (and some coloring)

```{r bird-obs-3, out.width='80%', fig.asp=.75, fig.align='center'}
d <- density(log(bird_obs$Count), na.rm=T)
plot(d, main = "density of log-transformed Counts")
polygon(d, col = "red", border = "blue")
```

**I**    

```{r, eval = FALSE}
#How many different species were recorded?
length(unique(bird_obs$Common.name))

#How many genera do they constitute?
length(unique(bird_obs$Genus))

#What species from the genus "Puffinus" have been observed?
#the actual sightings
bird_obs[bird_obs$Genus == "Puffinus", c(2, 3, 4, 6, 14)]
#the species
unique(bird_obs[bird_obs$Genus == "Puffinus", "Common.name"])
```

**J**    

```{r, eval = FALSE}
#these are the values that need to be rescued:
table(bird_obs[is.na(bird_obs$Count), "Number"])
#I suggest you take the lowest of the range-like values: 
#1-3 becomes 1; 2-3 becomes 2; 100s becomes 100 etc
#then do something like
tmp <- bird_obs$Number[1:50]
tmp
gsub("(\\d+)-(\\d+)", "\\1", tmp)
```


## Regular Expressions

### Restriction enzymes

**A**  

```{r eval = FALSE}
pacI_re <- "TTAATTAA"
patterns <- c("T{2}A{2}T{2}A{2}",
           "(TTAA){2}", 
           "(T{2}A{2}){2}")
for(ptrn in patterns){
    print(grepl(ptrn, pacI_re))
}
```

**B**  

```{r eval = FALSE}
sfiI_re <- "GGCCACGTAGGCC"
patterns <- c("G{2}C{2}[GATC]{5}G{2}C{2}",
           "GGCC[GATC]{5}GGCC", 
           "[GC]{4}[GATC]{5}[GC]{4}") #last one is less specific!
for(ptrn in patterns){
    print(grepl(ptrn, sfiI_re))
}
```

### Prosite Patterns  

**A**  

PS00211:  
"[LIVMFYC]-[SA]-[SAPGLVFYKQH]-G-[DENQMW]-[KRQASPCLIMFW]-[KRNQSTAVM]-[KRACLVM]-[LIVMFYPAN]-{PHY}-[LIVMFW]-[SAGCLIVP]-{FYWHP}-{KRHP}-[LIVMFYWSTA]." 

```{r}
PS00211<- "[LIVMFYC][SA][SAPGLVFYKQH]G[DENQMW][KRQASPCLIMFW][KRNQSTAVM][KRACLVM][LIVMFYPAN][^PHY][LIVMFW][SAGCLIVP][^FYWHP][^KRHP][LIVMFYWSTA]"
```

**B**  

PS00018: 
"D-{W}-[DNS]-{ILVFYW}-[DENSTG]-[DNQGHRK]-{GP}-[LIVMC]-[DENQSTAGC]-x(2)- [DE]-[LIVMFYW]." 

```{r}
PS00018 <- "D[^W][DNS][^ILVFYW][DENSTG][DNQGHRK][^GP][LIVMC][DENQSTAGC].{2} [DE][LIVMFYW]"
```


### Fasta Headers  

```{r}
library(stringr)
fasta_headers <- readLines("./data/fasta_headers.txt")
```

**A**  

```{r eval = FALSE}
str_match(fasta_headers, "\\[(.+)\\]")[, 2]
str_match(fasta_headers, "\\[([[:alpha:]]+ [[:alpha:]]+) ?(.+)?\\]")[, 2]
```

**B**  

```{r eval = FALSE}
str_match(fasta_headers, ">([[:alpha:]]{2,3}\\|\\w+)\\|")[, 2]
```

**C**  

```{r eval = FALSE}
str_match(fasta_headers, ">.+\\| (.+?) \\[")[, 2]
```



## Scripting

### Illegal reproductions

#### The mean {-}

```{r, eval = FALSE}
my_mean <- function(x) {
        sum(x, na.rm = T) / length(x)
}
``` 

#### Standard deviation {-}

```{r, eval = FALSE}
my_sd <- function(x) {
        sqrt(sum((x - mean(x))^2)/(length(x)-1))
}
```


#### Median {-}     

```{r, eval = FALSE}
my_median <- function(x) {
        sorted <- sort(x)
        if(length(x) %% 2 == 1) {
                #uneven length
                my_median <- sorted[ceiling(length(x)/2)]
        } else {
                my_median <- (sorted[length(x)/2] + sorted[(length(x)/2)+1]) / 2
        }
        return(my_median)
}
```


### Interquantile ranges

```{r eval = FALSE}
interquantile_range <- function(x, lower = 0, upper = 1) {
  if (! is.numeric(x) | 
      ! is.numeric(lower) |
      ! is.numeric(upper)) {
    stop("all three arguments should be numeric")
  }
  lower_val <- quantile(x, probs = lower)
  upper_val <- quantile(x, probs = upper)
  tmp <- upper_val - lower_val
  #a named vector is always nice, for acces but also for display purposes
  names(tmp) <- paste0(lower*100, "-", upper*100, "%")
  tmp
}
tst <- rnorm(1000)
interquantile_range(tst) # 0 to 1
interquantile_range(tst, 0.25, 0.75) # custom
#interquantile_range("foo") # error!
```

Perform some tests on the arguments to make a robust method: are all arguments numeric?
 
To test you method, you can compare `interquantile_range(some_vector, 0.25, 0.75)` with `IQR(some_vector)` - they should be the same.


### Vector distance

```{r vector-distance, eval = FALSE}
distance <- function(p, q) {
    if (! is.numeric(p) | ! is.numeric(q)) {
        stop("non-numeric vectors passed")
    }
    if (length(p) != length(q)) {
        stop("vectors have unequal length")
    }
    sqrt(sum((p - q)^2))
}
```


#### Other distance measures {-}

**`[NO SOLUTION YET]`**



### G/C percentage of DNA

```{r, eval = FALSE}
GC_perc <- function(seq, strict = TRUE) {
        if (is.na(seq)) {
                return(NA)
        }
        if (length(seq) == 0) {
                return(0)
        }
        seq.split <- strsplit(seq, "")[[1]]
        gc.count <- 0
        anom.count <- 0
        for (n in seq.split) {
                if (length(grep("[GATUCgatuc]", n)) > 0) {
                        if (n == "G" || n == "C") {
                                gc.count <- gc.count + 1
                        }
                } else {
                        if (strict) {
                                stop(paste("Illegal character", n))
                        } else {
                                anom.count <- anom.count + 1     
                        }
                }
        }
        ##return perc
        ##print(gc.count)
        if (anom.count > 0) {
                anom.perc <- anom.count / nchar(seq) * 100
                warning(paste("Non-DNA characters have percentage of", anom.perc))
        }
        return(gc.count / nchar(seq) * 100)
}
```



## Function `apply` and its relatives

### Whale selenium 


```{r read-remote-file-1}
whale_sel_url <- "https://raw.githubusercontent.com/MichielNoback/davur1/gh-pages/exercises/data/whale_selenium.txt"
whale_selenium <- read.table(whale_sel_url,
        header = T,
        row.names = 1)
```

**A**    

```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = mean)
```

**B** 

```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = sd)
```


**C**    

```{r, eval = FALSE}
my.sem <- function(x) {
        sem <- sd(x) / sqrt(length(x))
}
apply(X = whale_selenium, MARGIN = 2, FUN = my.sem)
```

**D**    

```{r whale-selenium-hist, out.width='80%', fig.asp=.75, fig.align='center'}
whale_selenium$ratio <- apply(X = whale_selenium, 
            MARGIN = 1, 
            FUN = function(x){
                    x[2] / x[1]
            })
hist(whale_selenium$ratio,
         xlab = "Tooth / Liver Selenium ratio",
         main = "Histogram of Tooth / Liver Selenium ratios")
```

**E** 

Inline expressions are like this: `r mean(cars$speed)` MpH.


### ChickWeight 

This exercise revolves around the `ChickWeight` dataset of the built-in `datasets` package. 

**A**    

```{r}
#MANY WAYS TO GET THERE
length(split(ChickWeight, ChickWeight$Chick))
#OR
sum(tapply(ChickWeight$Diet, ChickWeight$Chick, FUN = function(x){1}))
#OR
length(unique(ChickWeight$Chick))
#OR
nrow(aggregate(x = ChickWeight, by = list(ChickWeight$Chick), FUN = function(x){x}))
```

**B**    

```{r}
aggregate(formula = weight ~ Diet, data=ChickWeight, FUN = mean, na.rm = T)
#OR
aggregate(x = ChickWeight$weight, by = list(Diet = ChickWeight$Diet), FUN = mean, na.rm = T)
```

**C**    

```{r}
coplot(weight ~ Time | Diet, data = ChickWeight, panel = panel.smooth)
```

**D**    

```{r}
#A naive for-loop here - is this the best solution?
ChickWeight$weight_gain <- NA #create the column with missing values
for (i in 1:nrow(ChickWeight)) {
        #skip first row and rows that are preceded by values for another chick
        if (i > 1 && ChickWeight$Chick[i] == ChickWeight$Chick[i-1]) {
                ChickWeight[i, "weight_gain"] <- ChickWeight$weight[i] - ChickWeight$weight[i-1] 
        }
}
```

**E**    

```{r eval = F}
local_file <- "ChickWeight_weight_gain.Rdata"
download.file(paste0("https://github.com/MichielNoback/davur1_gitbook/raw/master/data/", local_file), local_file)
load(local_file)
#attach
ChickWeight$weight_gain <- stored.weight.gain
```

```{r eval = F}
tapply(X = ChickWeight$weight_gain, INDEX = ChickWeight$Diet, FUN = mean, na.rm = T)
#or with aggregate
aggregate(formula = weight_gain ~ Diet, data = ChickWeight, FUN = median)
#or with split and sapply
sapply(split(ChickWeight[, "weight_gain"], ChickWeight$Diet), sd, na.rm = T)
```

**F**    

```{r weight-gain-boxplot, out.width='80%', fig.asp=.75, fig.align='center'}
boxplot(weight_gain ~ Diet, data = ChickWeight)
```


### Food constituents 

**A**    

```{r}
foods <- read.table(
        "https://raw.githubusercontent.com/MichielNoback/davur1_gitbook/master/data/food_constituents.txt", header = T)
```

```{r eval = FALSE}
levels(foods$Type)
table(foods$Type)
```

**B**    

```{r eval = FALSE}
mean(foods[foods$Type == "chocolate", "kcal"])
```

**C**    

```{r eval = FALSE}
#aggregate over Type
mean.fat <- aggregate(formula = fat.total ~ Type, data = foods, FUN = mean)
#order and select first
mean.fat[order(mean.fat$fat.total, decreasing = T)[1], ]
```

**D**    

```{r eval = FALSE}
mean.energy <- aggregate(formula = kcal ~ Type, data = foods, FUN = mean)
mean.energy[order(mean.energy$kcal)[1], ]
mean.energy[order(mean.energy$kcal, decreasing = T)[1], ]
```

**E**    

```{r foods-boxplot, out.width='80%', fig.asp=.75, fig.align='center'}
#more verbose means possible; this efficient way demonstrating use of %in%
foods$solid.state <- !foods$Type %in% c("milk", "beverage")
boxplot(formula = carb.sugar ~ solid.state, 
                data = foods,
                main = "Sugar content of foods categories", 
                names = (c("Drink", "Solid")),
                ylab = "Sugar (g/100g product)")
```

**F**    

\[NO WORKED SOLUTION HERE\]



### Urine properties

The [urine specimens dataset](https://github.com/MichielNoback/datasets/tree/master/urine) contains a `readme.txt` file and a data file (`urine.csv`; direct link: "https://raw.githubusercontent.com/MichielNoback/datasets/master/urine/urine.csv"). Study the readme to get an idea of the data. Download the file like this:

```{r download-urine-data-2}
urine_file_name <- "urine.csv"
url <- paste0("https://raw.githubusercontent.com/MichielNoback/datasets/master/urine/", urine_file_name)
local_name <- paste0("../", urine_file_name) #specifiy your own folder!
download.file(url = url, destfile = local_name)
```

**A**  

Load the data into a dataframe with name `urine`.

```{r load-urine-data}
(urine <- read.table(local_name, 
                     sep = ",",
                     header = TRUE))
```

**B**  

Convert the column `r` into a factor with two levels: `yes` and `no`, and give it a better name: `ox_crystals`.

```{r convert-column-r}
names(urine)[2] <- "ox_crystals"
urine$ox_crystals <- factor(urine$ox_crystals, levels = c(0, 1), labels = c("no", "yes"))
```

**C**  

Using `apply()`, report the mean and standard deviation of the numeric columns only. Give these with only two decimal digits. Use a _named vector_ so you get this output:

```
     gravity   ph   osmo  cond   urea calc
mean    1.02 6.03 615.04 20.90 266.41 4.14
sd      0.01 0.72 238.25  7.95 131.25 3.26
```

```{r urine-mean-and-sd-1}
mean_sd <- function(x) {
    # returns a named vector
    c("mean" = round(mean(x, na.rm = T), 2), 
      "sd" = round(sd(x, na.rm = T), 2))
}
apply(X = urine[, 3:8], MARGIN = 2, FUN = mean_sd)
```

**D**  

Using `aggregate`, report the mean of the numeric columns, but split over the `ox_crystals` variable levels. Which variables seem most likely candidates for a relation with oxalate crystal formation.

```{r urine-mean-and-sd-2}
aggregate(cbind(gravity, ph, osmo, cond, urea, calc) ~ ox_crystals, 
          data = urine, 
          FUN = function(x) round(mean(x, na.rm = T), 2))
```

**E**  

Use the `pairs()` plotting function to explore the pairwise relationships between the different numeric variables  

```{r}
pairs(urine[, 3:8])
```

**F**  

Use the `heatmap.2()` and `cor()` functions together to create a heatmap of pairwise variable correlations. You will need to install package `gplots` for the heatmap.2 function. Alternatively, use `heatmap()` from base R.

Which visualization do you prefer - the `pairs()` or the `heatmap.2()`?

```{r}
#install.packages("gplots")
library("gplots")

cormat <- cor(urine[, 3:8], use = "complete.obs")
heatmap.2(cormat, col = bluered(100), trace = "none", density.info = "none")
```

**G**  

[**Challenge**] There does not seem to be an interesting correlation between pH and any of the other variables. Sometimes this is becuase you are not looking in enough detail. Let's dig a little further. Use `cut()` to split the pH variable into a factor with three levels:  "acidic", "neutral" and "basic" with breakpoints between them at pH 5.5 and 7. Next, use the `split()` and `lapply()` functions to calculate the mean, meadian and sd of the other numeric variables for each level of this pH factor. This exercise can of course be done in many ways. one of them is by using an `apply()` _within_ the applied function of `lapply()`.


```{r create-ph-factor}
ph_factor <- cut(urine$ph, 
    breaks = c(4.5, 5.5, 7.0, 8.0), 
    labels = c("acidic", "neutral", "basic"))
urine$ph_factor <- ph_factor

mean_median_sd <- function(x) {
    # X is a dataframe!
    apply(X = x[3:8],
          MARGIN = 2,
          FUN = function(y) {
              # returns a named vector
              c("mean" = round(mean(y, na.rm = T), 2), 
                "median" = median(y, na.rm = T),
                "sd" = round(sd(y, na.rm = T), 2))            
          })
}

urine_split <- split(x = urine, 
      f = urine$ph_factor)

lapply(X = urine_split,
       FUN = mean_median_sd)
```


### Bird observations revisited

```{r eval = FALSE}
bird_obs <- read.table("data/Observations-Data-2014.csv",
                                sep=";",
                                head=T,
                                na.strings = "",
                                quote = "",
                                comment.char = "",
                                as.is = c(1, 6, 7, 8, 13))
bird_obs$Count <- as.integer(bird_obs$Number)
```

**A**    

```{r bird-counts-barplot, out.width='80%', fig.asp=.75, fig.align='center'}
c.split <- split(x = bird_obs, f = bird_obs$County)
c.counts <- sapply(c.split, nrow)
barplot(c.counts[order(c.counts, decreasing = T)],
                main = "Bird observations per county",
                ylab = "Observations",
                las = 2)
```

**B**    

```{r eval = FALSE}
obs.split <- split(x = bird_obs, f = bird_obs$Observer.1)
obs.counts <- sapply(obs.split, nrow)
obs.counts <- obs.counts[obs.counts > 10]
obs.counts[order(obs.counts, decreasing = T)]
```

**C**    

```{r eval = FALSE}
obs.counts[order(obs.counts, decreasing = T)][1]
```

**D**    

```{r eval = FALSE}
g.split <- split(bird_obs, bird_obs$Genus)
g.species <- lapply(g.split, function(x) {
        unique(x$Common.name)
})
#create ordering
g.species.count <- sapply(g.species, length)
g.order <- order(g.species.count, decreasing = T)
#apply order to list and select only first five
g.species[g.order[1:5]]
```

**E**    

```{r eval = FALSE}
bird_obs$Date.start <- as.Date(bird_obs$Date.start, format = "%d-%b-%y")
date.series <- aggregate(Count ~ Date.start, data = bird_obs, FUN = sum, na.rm = T)
#2024 is an error input, remove it
date.series <- date.series[1:nrow(date.series)-1, ]
plot(x = date.series$Date.start, y = date.series$Count, ylim = c(0, 250))
```


