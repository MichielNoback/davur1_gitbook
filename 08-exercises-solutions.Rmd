# Exercise solutions

```{r}
#this is for rounding numbers in this session
options(digits=3)
```

## Toolbox

### Get set up

No solution for this one.

### Résumé

No solution for this one.


## Basic R

### Math in the console

```{r results = 'hold'}
31 + 11
66 - 24
126 / 3
12^2 
256**0.5
(3 * (4 + 8^0.5))/(5^3)
```


### First look at functions

**A**  
Answer: `paste()` and `paste0()`. The difference lies in the _separator_, which is an empty string in `paste0()` and one space in `paste()`. Moreover, the separator can be configured in `paste()` using the `sep = ` parameter.

```{r paste-ex-1}
paste("welcome ", "to ", "R", sep = "")
paste0("welcome ", "to ", "R")
```

**B**  
Answer: `abs()` returns the _absolute_ value. Simply put, a number with the minus sign removed if present.

```{r abs-ex-1}
abs(-20)
abs(20)
```

**C**  
Answer: it combines (**c**oncatenates) its arguments into a single vector. The first example creates a "character" (text data) and the second a "numeric" (numeric data).

```{r c-ex-1}
c(1, 2, "a")
class(c(1, 2, "a"))
c(1, 2, 3)
class(c(1, 2, 3))
```


**D**  

```{r install-packages-demo-1, eval = FALSE}
#install it. Note the quotes
install.packages("RColorBrewer")
#load it into your session. Note the absence of quotes
library(RColorBrewer)
```


### Variables

```{r variables-ex-1}
x <- 20
y <- 10
z <- 3

x + y
x^z
#OR
#x**z
q <- x * y * z
sqrt(q)
q/pi
log10(x * y)
```

### Vectors

#### Circles {-}

The circumference of a circle is $2\pi\cdot r$, its surface $4\pi \cdot r^2$ and its volume $4/3 \pi\cdot r^3$.
Given this vector of circle radiuses,

```{r radiuses-defined}
radiuses <- c(0, 1, 2, pi, 4)
```

**A**  
Calculate their cirumference.

```{r circle-circumference}
2 * pi * radiuses
```

**B**  
Calculate their surface.

```{r circle-surface}
4 * pi * radiuses^2
```

**C**  
Calculate their volume.

```{r circle-volume}
4/3 * pi * radiuses^3
```

#### Creating vectors {-}

Create the following vectors, as efficiently as possible. The functions `rep()`, `seq()` and `paste0()` and the colon operator `:` can be used, in any combination.


**A**   
`[1] 1 2 5 1 2 5`

```{r create-vector-A}
rep(c(1, 2, 5), times = 2)
```


**B**  
`[1] 9 9 9 8 8 8 7 7 7 6 6 6 5 5 5`

```{r create-vector-B}
rep(9:5, each = 3)
```

**C**  
` [1] 1 1 1 4 4 4 9 9 9 1 1 1 4 4 4 9 9 9`

```{r create-vector-C}
rep(c(1, 4, 9), times = 2, each = 3)
```

**D**  
` [1] "1a" "2b" "3c" "4d" "5e" "1a" "2b" "3c" "4d" "5e"`

```{r create-vector-D}
rep(paste0(1:5, letters[1:5]), times = 2)
```

**E**  
`[1] "0z"   "0.2y" "0.4x" "0.6w" "0.8v" "1u"`

```{r create-vector-E}
paste0(seq(from = 0, to = 1, length.out = 6), letters[26:21])
```

**F**  
`[1] "505" "404" "303" "202" "101" "000"`
```{r create-vector-F}
paste0(5:0, 0, 5:0)
```

**G [Challenge]**  
`[1] "0.5A5.0" "0.4B4.0" "0.3C3.0" "0.2D2.0" "0.1E1.0"`

```{r create-vector-G}
paste0(seq(from = 0.5, to = 0.1, by = -0.1),  LETTERS[1:5], 5:1, ".0")
```



### Stair walking and heart rate 

```{r stair-walking-exp-1, out.width='80%', fig.asp=.75, fig.align='center'}
#number of steps on the stairs
stair_height <- c(0, 5, 10, 15, 20, 25, 30, 35)
#heart rate after ascending the stairs
heart_rate <- c(66, 65, 67, 69, 73, 79, 86, 97)
plot(heart_rate ~ stair_height,
      main = "Heart rate versus stair height",
      xlab = "number of steps",
      ylab = "heart rate (beats/minute)",
      type = "l",
      lwd = 2,
      col = "blue")
```

### More subjects

```{r stair-walking-exp-2, out.width='80%', fig.asp=.75, fig.align='center'}
#number of steps on the stairs
stair_height <- c(0, 5, 10, 15, 20, 25, 30, 35)
#heart rates for subjects with normal weight
heart_rate_1 <- c(66, 65, 67, 69, 73, 79, 86, 97)
heart_rate_2 <- c(61, 61, 63, 68, 74, 81, 89, 104)
#heart rates for obese subjects
heart_rate_3 <- c(58, 60, 67, 71, 78, 89, 104, 121)
heart_rate_4 <- c(69, 73, 77, 83, 88, 96, 102, 127)
plot(x = stair_height,
    y = heart_rate_1,
    main = "Heart rate vs stair height",
    xlab = "number of steps",
    ylab = "heart rate (beats/min.)",
    type = "b",
    lwd = 2,
    col = "green",
    ylim = c(55, 130))
points(x = stair_height,
    y = heart_rate_2,
    col = "green",
    type = "b",
    lwd = 2)
points(x = stair_height,
    y = heart_rate_3,
    col = "red",
    type = "b",
    lwd = 2)
points(x = stair_height,
    y = heart_rate_4,
    col = "red",
    type = "b",
    lwd = 2)
```

Yes! there is a better more efficient way to do this, but we have not dealt with that yet.

### Chickens on a diet

```{r chicken-diets1, out.width='80%', fig.asp=.75, fig.align='center'}

time <- c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 21)
chick_1 <- c(42, 51, 59, 64, 76, 93, 106, 125, 149, 171, 199, 205)
chick_2 <- c(40, 49, 58, 72, 84, 103, 122, 138, 162, 187, 209, 215)
chick_3 <- c(42, 53, 62, 73, 85, 102, 123, 138, 170, 204, 235, 256)
chick_4 <- c(41, 49, 61, 74, 98, 109, 128, 154, 192, 232, 280, 290)

plot(x = time, y = chick_1,
         type = "l",
         lwd = 2,
         col = "blue",
         ylim = c(40, 300))
points(x = time, y = chick_2,
         type = "l",
         lwd = 2,
         lty = 3,
         col = "blue")
points(x = time, y = chick_3,
         type = "l",
         lwd = 2,
         lty = 1,
         col = "red")
points(x = time, y = chick_4,
         type = "l",
         lwd = 2,
         lty = 3,
         col = "red")
```

### Chicken bar plot

```{r chicken-diets2, out.width='80%', fig.asp=.75, fig.align='center'}
maxima <- c(max(chick_1), max(chick_2), max(chick_3), max(chick_4))

barplot(maxima,
    names = c("Chick 1","Chick 2","Chick 3","Chick 4"),
    ylab = "Maximum weight (grams)",
    col = "gold",
    main = "Maximum chick weights")
```

### Discoveries 

**A**    
```{r discoveries-1, out.width='80%', fig.asp=.75, fig.align='center'}
barplot(table(discoveries),
    main = "great discoveries per year",
    xlab = "number of discoveries",
    ylab = "frequency",
    col = "green")
```

**B**    
```{r discoveries-2, eval = FALSE}
summary(discoveries)
```

**C**    
```{r discoveries-3, out.width='80%', fig.asp=.75, fig.align='center'}
plot(discoveries,
         xlab = "year",
         ylab = "number of discoveries",
         main = "Great discoveries",
         col = "blue", 
         lwd = 2)
```


### Lung cancer    

**A**    
```{r lung-cancer-1, out.width='80%', fig.asp=.75, fig.align='center'}
total.col <- "red"
m.col <- "blue"
f.col <- "green"
plot(ldeaths,
         main = "deaths from lung cancer",
         xlab = "year",
         ylab = "number",
         col = total.col,
         ylim = c(0, 4000),
         lwd = 2
)
lines(fdeaths, col = f.col, lwd = 2)
lines(mdeaths, col = m.col, lwd = 2)
legend(
    "topleft", 
    legend = c("total", "female", "male"), 
    col = c(total.col, f.col, m.col), 
    lty = 1)
```

**B**   

```{r lung-cancer-2, out.width='80%', fig.asp=.75, fig.align='center'}
boxplot(
    fdeaths, mdeaths, ldeaths
)
```

ANSWER: You can see a single outlier in the `fdeaths` set. We can identify the year by finding out when this occurred:

```{r finding-outliers}
max(fdeaths) ## 1141
which(fdeaths == max(fdeaths)) ## index 26
fdeaths
```

So this was February 1976. A quick Google search turned up a pdf document "CDC Influenza Surveillance" that states 

> "The 1975-1976 influenza season was noteworthy because of several events. a) An H3N2 influenza virus (A/Victoria/3/75), isolated first in April 1975, caused a wide- spread epidemic late in the influenza season in the United States. Based on pneumonia- and influenza-associated mortality which peaked in February and March 1976, this was the most severe epidemic experienced by the United States since the 1968-1969 Hong Kong epidemic."

([direct link](https://stacks.cdc.gov/view/cdc/287/cdc_287_DS1.pdf))

As you may know, (lung) cancer patients are especially vulnerable for influenza infections.

## Complex datatypes

### Creating factors

**A**  
```{r eval = FALSE}
animal_risk <- c(2, 4, 1, 1, 2, 4, 1, 4, 1, 1, 2, 1)
animal_risk_factor <- factor(x = animal_risk,
                             levels = c(1, 2, 3, 4),
                             labels = c("harmless", "risky", "dangerous", "deadly"),
                             ordered = TRUE)
barplot(table(animal_risk_factor))
```

**B**  
```{r}
set.seed(1234)
wealth_male <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.7, 0.17, 0.12, 0.01))
wealth_female <- sample(x = letters[1:4], 
                 size = 1000,
                 replace= TRUE, 
                 prob = c(0.8, 0.15, 0.497, 0.003))

wealth_labels <- c("poor", "middle class", "wealthy", "rich")

wealth_male_f <- factor(x = wealth_male,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

wealth_female_f <- factor(x = wealth_female,
                        levels = letters[1:4],
                        labels = wealth_labels,
                        ordered = TRUE)

#combine
wealth_all_f <- factor(c(wealth_male_f, wealth_female_f),
                        levels = 1:4,
                        labels = wealth_labels,
                        ordered = TRUE)

prop.table(table(wealth_all_f)) * 100

#getting this data right may be a bit of a challenge...
bar_data <- rbind(table(wealth_female_f), table(wealth_male_f))
rownames(bar_data) <- c("female", "male")

barplot(bar_data, beside = T, legend = rownames(bar_data))
```


### A dictionary with a named vector

**A**    
```{r named-vector-1}
codons <- c("G", "P", "K", "S")
names(codons) <- c("GGA", "CCU", "AAA", "AGU")

my_DNA <- "GGACCUAAAAGU"
my_prot <- ""
for (i in seq(from = 1, to = nchar(my_DNA), by = 3)) {
        codon <- substr(my_DNA, i, i+2)
        my_prot <- paste0(my_prot, codons[codon])
}
print(my_prot)
```

**B**    
```{r eval = F}
nuc_weights <- c(491.2, 467.2, 507.2, 482.2)
names(nuc_weights) <- c('A', 'C', 'G', 'U')

mol_weight <- 0
for (i in 1:nchar(my_DNA)) {
        nuc <- substr(my_DNA, i, i);
        print(nuc)
        mol_weight <- mol_weight + nuc_weights[nuc]
}
mol_weight
```


### airquality 

**A**    
```{r airquality-1, out.width='80%', fig.asp=.75, fig.align='center'}
plot(airquality$Solar.R, airquality$Temp,
         main = "Temperature as a function of Solar radiation",
         xlab = "Solar radiation (lang)",
         ylab = "Temperature (F)")
abline(lm(airquality$Temp ~ airquality$Solar.R), col = "blue", lwd = 2)
```

**B**    
```{r airquality-2, out.width='80%', fig.asp=.75, fig.align='center'}
with(airquality, 
        boxplot(Temp ~ Month, 
        main = "Temperature over the months",
        xlab = "Month",
        ylab = "Temperature (F)"))
```

**C**    
```{r airquality-3, out.width='80%', fig.asp=.75, fig.align='center'}
#first create Temp Celcius column:
#(°F    -    32)    x    5/9 = °C
airquality$Temp.C <- (airquality$Temp - 32) * 5/9
#get the required data
airquality[airquality$Temp.C == min(airquality$Temp.C), c("Temp.C", "Month", "Day")]
```

**D**    
```{r airquality-4, out.width='80%', fig.asp=.75, fig.align='center'}
hist(airquality$Wind, xlab = "Wind speed (mph)")
abline(v = mean(airquality$Wind), col = "blue", lwd = 2)
abline(v = median(airquality$Wind), col = "red", lwd = 2)
```

**E**    
```{r airquality-5, out.width='80%', fig.asp=.75, fig.align='center'}
pairs(airquality, panel = panel.smooth)
```

Calculate pairwise correlation.
```{r airquality-cor, eval = FALSE}
cor(na.omit(airquality))
```


### Bird observations

```{r load-bird-observations}
bird_obs <- read.table("data/Observations-Data-2014.csv", 
                                             sep=";", 
                                             head=T, 
                                             na.strings = "", 
                                             quote = "", 
                                             comment.char = "")
```


**A**    
```{r, eval = FALSE}
## look at the loaded data structure
str(bird_obs)
```

Apparently, all variables are loaded as a factor; also the `Date.start`, `Date.end` (should be dates of course), `Number` (should be `integer`) and `Notes` (should be `character`) columns. In the original column names there are spaces and these are replaced by dots. First column `Species..` is a serial number and the second `Species` is the English species name.

**B**    
```{r, eval = FALSE}
nrow(bird_obs)
```

**C**    
```{r, eval = FALSE}
class(bird_obs$Number)
```

**D**    
```{r}
bird_obs$Count <- as.integer(bird_obs$Number)
head(bird_obs[, c(4, 8, 14)], n=50)
```

The factor **_levels_** have been converted into integers, not the original values!

**E**    
```{r}
#read with as.is argument
bird_obs <- read.table("data/Observations-Data-2014.csv",
                                sep=";",
                                head=T,
                                na.strings = "",
                                quote = "",
                                comment.char = "",
                                as.is = c(1, 6, 7, 8, 13))
str(bird_obs)
```

Convert Number column to Count of integers.

```{r}
bird_obs$Count <- as.integer(bird_obs$Number)
```

Note that there are other ways to achieve this, e.g. the `colClasses` argument to `read.table()`.

**F**    
```{r, eval = FALSE}
head(bird_obs[, c(4, 8, 14)], n=50)
sum(is.na(bird_obs$Count))
```

**G**    
```{r, eval = FALSE}
#What is the maximum number of birds in a single sighting?
bird_obs[which(bird_obs$Count == max(bird_obs$Count, na.rm = T)), ]
##OR
bird_obs[!is.na(bird_obs$Count) & bird_obs$Count == max(bird_obs$Count, na.rm = T), ]

#What is the mean sighting count
mean(bird_obs$Count, na.rm = T)

#What is the median of the sighting count
median(bird_obs$Count, na.rm = T)
```

**H**    
```{r bird-obs-1, out.width='80%', fig.asp=.75, fig.align='center'}
hist(bird_obs$Count)
```

Not very helpful, now is it? Try fiddling with the `breaks` argument.

```{r bird-obs-2, out.width='80%', fig.asp=.75, fig.align='center'}
plot(density(bird_obs$Count, na.rm=T),
         main = "density of Counts")
```

Better results with a log transformation (and some coloring)

```{r bird-obs-3, out.width='80%', fig.asp=.75, fig.align='center'}
d <- density(log(bird_obs$Count), na.rm=T)
plot(d, main = "density of log-transformed Counts")
polygon(d, col = "red", border = "blue")
```

**I**    
```{r, eval = FALSE}
#How many different species were recorded?
length(unique(bird_obs$Common.name))

#How many genera do they constitute?
length(unique(bird_obs$Genus))

#What species from the genus "Puffinus" have been observed?
#the actual sightings
bird_obs[bird_obs$Genus == "Puffinus", c(2, 3, 4, 6, 14)]
#the species
unique(bird_obs[bird_obs$Genus == "Puffinus", "Common.name"])
```

**J**    
```{r, eval = FALSE}
#these are the values that need to be rescued:
table(bird_obs[is.na(bird_obs$Count), "Number"])
#I suggest you take the lowest of the range-like values: 
#1-3 becomes 1; 2-3 becomes 2; 100s becomes 100 etc
#then do something like
tmp <- bird_obs$Number[1:50]
tmp
gsub("(\\d+)-(\\d+)", "\\1", tmp)
```


## Regular Expressions

### Restriction enzymes

**A**  
```{r eval = FALSE}
pacI_re <- "TTAATTAA"
patterns <- c("T{2}A{2}T{2}A{2}",
           "(TTAA){2}", 
           "(T{2}A{2}){2}")
for(ptrn in patterns){
    print(grepl(ptrn, pacI_re))
}
```

**B**  
```{r eval = FALSE}
sfiI_re <- "GGCCACGTAGGCC"
patterns <- c("G{2}C{2}[GATC]{5}G{2}C{2}",
           "GGCC[GATC]{5}GGCC", 
           "[GC]{4}[GATC]{5}[GC]{4}") #last one is less specific!
for(ptrn in patterns){
    print(grepl(ptrn, sfiI_re))
}
```

### Prosite Patterns  

**A**  
PS00211:  
"[LIVMFYC]-[SA]-[SAPGLVFYKQH]-G-[DENQMW]-[KRQASPCLIMFW]-[KRNQSTAVM]-[KRACLVM]-[LIVMFYPAN]-{PHY}-[LIVMFW]-[SAGCLIVP]-{FYWHP}-{KRHP}-[LIVMFYWSTA]." 

```{r}
PS00211<- "[LIVMFYC][SA][SAPGLVFYKQH]G[DENQMW][KRQASPCLIMFW][KRNQSTAVM][KRACLVM][LIVMFYPAN][^PHY][LIVMFW][SAGCLIVP][^FYWHP][^KRHP][LIVMFYWSTA]"
```

**B**  
PS00018: 
"D-{W}-[DNS]-{ILVFYW}-[DENSTG]-[DNQGHRK]-{GP}-[LIVMC]-[DENQSTAGC]-x(2)- [DE]-[LIVMFYW]." 

```{r}
PS00018 <- "D[^W][DNS][^ILVFYW][DENSTG][DNQGHRK][^GP][LIVMC][DENQSTAGC].{2} [DE][LIVMFYW]"
```


### Fasta Headers  

```{r}
library(stringr)
fasta_headers <- readLines("./data/fasta_headers.txt")
```

**A**  
```{r eval = FALSE}
str_match(fasta_headers, "\\[(.+)\\]")[, 2]
str_match(fasta_headers, "\\[([[:alpha:]]+ [[:alpha:]]+) ?(.+)?\\]")[, 2]
```

**B**  
```{r eval = FALSE}
str_match(fasta_headers, ">([[:alpha:]]{2,3}\\|\\w+)\\|")[, 2]
```

**C**  
```{r eval = FALSE}
str_match(fasta_headers, ">.+\\| (.+?) \\[")[, 2]
```



## Scripting

### Illegal reproductions

#### The mean {-}

```{r, eval = FALSE}
my_mean <- function(x) {
        sum(x, na.rm = T) / length(x)
}
``` 

#### Standard deviation {-}

```{r, eval = FALSE}
my_sd <- function(x) {
        sqrt(sum((x - mean(x))^2)/(length(x)-1))
}
```


#### Median {-}     

```{r, eval = FALSE}
my_median <- function(x) {
        sorted <- sort(x)
        if(length(x) %% 2 == 1) {
                #uneven length
                my_median <- sorted[ceiling(length(x)/2)]
        } else {
                my_median <- (sorted[length(x)/2] + sorted[(length(x)/2)+1]) / 2
        }
        return(my_median)
}
```


### Interquantile ranges

```{r eval = FALSE}
interquantile_range <- function(x, lower = 0, upper = 1) {
  if (! is.numeric(x) | 
      ! is.numeric(lower) |
      ! is.numeric(upper)) {
    stop("all three arguments should be numeric")
  }
  lower_val <- quantile(x, probs = lower)
  upper_val <- quantile(x, probs = upper)
  tmp <- upper_val - lower_val
  #a named vector is always nice, for acces but also for display purposes
  names(tmp) <- paste0(lower*100, "-", upper*100, "%")
  tmp
}
tst <- rnorm(1000)
interquantile_range(tst) # 0 to 1
interquantile_range(tst, 0.25, 0.75) # custom
#interquantile_range("foo") # error!
```

Perform some tests on the arguments to make a robust method: are all arguments numeric?
 
To test you method, you can compare `interquantile_range(some_vector, 0.25, 0.75)` with `IQR(some_vector)` - they should be the same.


### Vector distance

```{r vector-distance, eval = FALSE}
distance <- function(p, q) {
    if (! is.numeric(p) | ! is.numeric(q)) {
        stop("non-numeric vectors passed")
    }
    if (length(p) != length(q)) {
        stop("vectors have unequal length")
    }
    sqrt(sum((p - q)^2))
}
```


#### Other distance measures {-}

**`[NO SOLUTION YET]`**



### G/C percentage of DNA

```{r, eval = FALSE}
GC_perc <- function(seq, strict = TRUE) {
        if (is.na(seq)) {
                return(NA)
        }
        if (length(seq) == 0) {
                return(0)
        }
        seq.split <- strsplit(seq, "")[[1]]
        gc.count <- 0
        anom.count <- 0
        for (n in seq.split) {
                if (length(grep("[GATUCgatuc]", n)) > 0) {
                        if (n == "G" || n == "C") {
                                gc.count <- gc.count + 1
                        }
                } else {
                        if (strict) {
                                stop(paste("Illegal character", n))
                        } else {
                                anom.count <- anom.count + 1     
                        }
                }
        }
        ##return perc
        ##print(gc.count)
        if (anom.count > 0) {
                anom.perc <- anom.count / nchar(seq) * 100
                warning(paste("Non-DNA characters have percentage of", anom.perc))
        }
        return(gc.count / nchar(seq) * 100)
}
```



## Function `apply` and its relatives

### Whale selenium 


```{r read-remote-file-1}
whale_sel_url <- "https://raw.githubusercontent.com/MichielNoback/davur1/gh-pages/exercises/data/whale_selenium.txt"
whale_selenium <- read.table(whale_sel_url,
        header = T,
        row.names = 1)
```

**A**    
```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = mean)
```

**B**  
```{r, eval = FALSE}
apply(X = whale_selenium, MARGIN = 2, FUN = sd)
```


**C**    
```{r, eval = FALSE}
my.sem <- function(x) {
        sem <- sd(x) / sqrt(length(x))
}
apply(X = whale_selenium, MARGIN = 2, FUN = my.sem)
```

**D**    
```{r whale-selenium-hist, out.width='80%', fig.asp=.75, fig.align='center'}
whale_selenium$ratio <- apply(X = whale_selenium, 
            MARGIN = 1, 
            FUN = function(x){
                    x[2] / x[1]
            })
hist(whale_selenium$ratio,
         xlab = "Tooth / Liver Selenium ratio",
         main = "Histogram of Tooth / Liver Selenium ratios")
```

**E**  
Inline expressions are like this: `r mean(cars$speed)` MpH.


### ChickWeight 

This exercise revolves around the `ChickWeight` dataset of the built-in `datasets` package. 

**A**    
```{r}
#MANY WAYS TO GET THERE
length(split(ChickWeight, ChickWeight$Chick))
#OR
sum(tapply(ChickWeight$Diet, ChickWeight$Chick, FUN = function(x){1}))
#OR
length(unique(ChickWeight$Chick))
#OR
nrow(aggregate(x = ChickWeight, by = list(ChickWeight$Chick), FUN = function(x){x}))
```

**B**  
```{r}
aggregate(formula = weight ~ Diet, data=ChickWeight, FUN = mean, na.rm = T)
#OR
aggregate(x = ChickWeight$weight, by = list(Diet = ChickWeight$Diet), FUN = mean, na.rm = T)
```

**C**  
```{r}
coplot(weight ~ Time | Diet, data = ChickWeight, panel = panel.smooth)
```

**D**  
```{r}
#A naive for-loop here - is this the best solution?
ChickWeight$weight_gain <- NA #create the column with missing values
for (i in 1:nrow(ChickWeight)) {
        #skip first row and rows that are preceded by values for another chick
        if (i > 1 && ChickWeight$Chick[i] == ChickWeight$Chick[i-1]) {
                ChickWeight[i, "weight_gain"] <- ChickWeight$weight[i] - ChickWeight$weight[i-1] 
        }
}
```

**E**  
```{r eval = F}
local_file <- "ChickWeight_weight_gain.Rdata"
download.file(paste0("https://github.com/MichielNoback/davur1_gitbook/raw/master/data/", local_file), local_file)
load(local_file)
#attach
ChickWeight$weight_gain <- stored.weight.gain
```

```{r eval = F}
tapply(X = ChickWeight$weight_gain, INDEX = ChickWeight$Diet, FUN = mean, na.rm = T)
#or with aggregate
aggregate(formula = weight_gain ~ Diet, data = ChickWeight, FUN = median)
#or with split and sapply
sapply(split(ChickWeight[, "weight_gain"], ChickWeight$Diet), sd, na.rm = T)
```

**F**  
```{r weight-gain-boxplot, out.width='80%', fig.asp=.75, fig.align='center'}
boxplot(weight_gain ~ Diet, data = ChickWeight)
```


### Food constituents 

**A**  
```{r}
foods <- read.table(
        "https://raw.githubusercontent.com/MichielNoback/davur1_gitbook/master/data/food_constituents.txt", header = T)
```

```{r eval = FALSE}
levels(foods$Type)
table(foods$Type)
```

**B**  
```{r eval = FALSE}
mean(foods[foods$Type == "chocolate", "kcal"])
```

**C**  
```{r eval = FALSE}
#aggregate over Type
mean.fat <- aggregate(formula = fat.total ~ Type, data = foods, FUN = mean)
#order and select first
mean.fat[order(mean.fat$fat.total, decreasing = T)[1], ]
```

**D**  
```{r eval = FALSE}
mean.energy <- aggregate(formula = kcal ~ Type, data = foods, FUN = mean)
mean.energy[order(mean.energy$kcal)[1], ]
mean.energy[order(mean.energy$kcal, decreasing = T)[1], ]
```

**E**  
```{r foods-boxplot, out.width='80%', fig.asp=.75, fig.align='center'}
#more verbose means possible; this efficient way demonstrating use of %in%
foods$solid.state <- !foods$Type %in% c("milk", "beverage")
boxplot(formula = carb.sugar ~ solid.state, 
                data = foods,
                main = "Sugar content of foods categories", 
                names = (c("Drink", "Solid")),
                ylab = "Sugar (g/100g product)")
```

**F**  
\[NO WORKED SOLUTION HERE\]



### Urine properties


```{r download-urine-data-2}
urine_file_name <- "urine.csv"
url <- paste0("https://raw.githubusercontent.com/MichielNoback/datasets/master/urine/", urine_file_name)
local_name <- paste0("../", urine_file_name) #specifiy your own folder!
download.file(url = url, destfile = local_name)
```

**A**  
```{r load-urine-data}
urine <- read.table(local_name, 
                     sep = ",",
                     header = TRUE)
```

**B**  
```{r convert-column-r}
names(urine)[2] <- "ox_crystals"
urine$ox_crystals <- factor(urine$ox_crystals, levels = c(0, 1), labels = c("no", "yes"))
```

**C**  
```{r urine-mean-and-sd-1}
mean_sd <- function(x) {
    # returns a named vector
    c("mean" = round(mean(x, na.rm = T), 2), 
      "sd" = round(sd(x, na.rm = T), 2))
}
apply(X = urine[, 3:8], MARGIN = 2, FUN = mean_sd)
```

**D**  
```{r urine-mean-and-sd-2}
aggregate(cbind(gravity, ph, osmo, cond, urea, calc) ~ ox_crystals, 
          data = urine, 
          FUN = function(x) round(mean(x, na.rm = T), 2))
```

**E**  
```{r}
pairs(urine[, 3:8])
```

**F**  
```{r}
#install.packages("gplots")
library("gplots")
cormat <- cor(urine[, 3:8], use = "complete.obs")
heatmap.2(cormat, col = bluered(100), trace = "none", density.info = "none")
```

**G**  
```{r create-ph-factor}
ph_factor <- cut(urine$ph, 
    breaks = c(4.5, 5.5, 7.0, 8.0), 
    labels = c("acidic", "neutral", "basic"))
urine$ph_factor <- ph_factor

mean_median_sd <- function(x) {
    # X is a dataframe!
    apply(X = x[3:8],
          MARGIN = 2,
          FUN = function(y) {
              # returns a named vector
              c("mean" = round(mean(y, na.rm = T), 2), 
                "median" = median(y, na.rm = T),
                "sd" = round(sd(y, na.rm = T), 2))            
          })
}

urine_split <- split(x = urine, 
      f = urine$ph_factor)

lapply(X = urine_split,
       FUN = mean_median_sd)
```


### Bird observations revisited

```{r eval = FALSE}
bird_obs <- read.table("data/Observations-Data-2014.csv",
                                sep=";",
                                head=T,
                                na.strings = "",
                                quote = "",
                                comment.char = "",
                                as.is = c(1, 6, 7, 8, 13))
bird_obs$Count <- as.integer(bird_obs$Number)
```

**A**    
```{r bird-counts-barplot, out.width='80%', fig.asp=.75, fig.align='center'}
c.split <- split(x = bird_obs, f = bird_obs$County)
c.counts <- sapply(c.split, nrow)
barplot(c.counts[order(c.counts, decreasing = T)],
                main = "Bird observations per county",
                ylab = "Observations",
                las = 2)
```

**B**    
```{r eval = FALSE}
obs.split <- split(x = bird_obs, f = bird_obs$Observer.1)
obs.counts <- sapply(obs.split, nrow)
obs.counts <- obs.counts[obs.counts > 10]
obs.counts[order(obs.counts, decreasing = T)]
```

**C**    
```{r eval = FALSE}
obs.counts[order(obs.counts, decreasing = T)][1]
```

**D**    
```{r eval = FALSE}
g.split <- split(bird_obs, bird_obs$Genus)
g.species <- lapply(g.split, function(x) {
        unique(x$Common.name)
})
#create ordering
g.species.count <- sapply(g.species, length)
g.order <- order(g.species.count, decreasing = T)
#apply order to list and select only first five
g.species[g.order[1:5]]
```

**E**  
```{r eval = FALSE}
bird_obs$Date.start <- as.Date(bird_obs$Date.start, format = "%d-%b-%y")
date.series <- aggregate(Count ~ Date.start, data = bird_obs, FUN = sum, na.rm = T)
#2024 is an error input, remove it
date.series <- date.series[1:nrow(date.series)-1, ]
plot(x = date.series$Date.start, y = date.series$Count, ylim = c(0, 250))
```


